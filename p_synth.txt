10001100000100000000000000000100	//LI $1 4			Carrega 4 no $1
10001100001000000000000000000011	//LI $2 3			Carrega 3 no $2
11111000001000000100000000000000	//SW $2 $1			Guarda o conteúdo de $2 no endereço $1 da RAM
11001000001100000100000000000000	//LW $3 $1			Carrega o conteúdo do endereço $1 da RAM no $3
10010000001100000000000000000000	//OUT $3			Printa o conteudo de $3 (3)
11010000001100000100000000000000	//MOVE $3 $1		Copia o conteudo de $1 para $3
10010000001100000000000000000000	//OUT $3			Printa $3 (4)
11110100001100000100000000000010	//SUBI $3 $1 2		Faz $3 = $1 - 2
10010000001100000000000000000000	//OUT $3			Printa $3 (2)
11010100001100000100000000000010	//MULI $3 $1 2		Faz $3 = $1 * 2
10010000001100000000000000000000	//OUT $3			Printa $3 (8)
11000100001100000100000000000010	//DIVI $3 $1 2		Faz $3 = $1 / 2
10010000001100000000000000000000	//OUT $3			Printa $3 (2)
11001100001100000100000000000010	//MODI $3 $1 2		Faz $3 = $1 % 2
10010000001100000000000000000000	//OUT $3			Printa $3 (0)
11100100001100000100000000000010	//STEQI $3 $1 2		Faz $3 = 1, se $1 = 2. Senão $3 = 0
10010000001100000000000000000000	//OUT $3			Printa $3 (0)
11101000001100000100000000000010	//STGTI $3 $1 2		Faz $3 = 1, se $1 > 2. Senão $3 = 0
10010000001100000000000000000000	//OUT $3			Printa $3 (1)
11101100001100000100000000000010	//STLTI $3 $1 2		Faz $3 = 1, se $1 < 2. Senão $3 = 0
10010000001100000000000000000000	//OUT $3			Printa $3 (0)
11110000001100000100000000000010	//STNEI $3 $1 2		Faz $3 = 1, se $1 != 2. Senão $3 = 0
10010000001100000000000000000000	//OUT $3			Printa $3 (1)
00000000001100000100001000000000	//ADD $3 $1 $2		Faz $3 = $1 + $2
10010000001100000000000000000000	//OUT $3			Printa $3 (7)
01001000001100000100001000000000	//SUB $3 $1 $2		Faz $3 = $1 - $2
10010000001100000000000000000000	//OUT $3			Printa $3 (7)
00101100001100000100001000000000	//MUL $3 $1 $2		Faz $3 = $1 * $2
10010000001100000000000000000000	//OUT $3			Printa $3 (C, 12 em hexadecimal)
00100000001100000100001000000000	//DIV $3 $1 $2		Faz $3 = $1 / $2
10010000001100000000000000000000	//OUT $3			Printa $3 (1)
00101000001100000100001000000000	//MOD $3 $1 $2		Faz $3 = $1 % $2
10010000001100000000000000000000	//OUT $3			Printa $3 (1)
00000100001100000100001000000000	//AND $3 $1 $2		Faz $3 = $1 & $2 (bitwise)
10010000001100000000000000000000	//OUT $3			Printa $3 (0)
00110100001100000100001000000000	//OR $3 $1 $2		Faz $3 = $1 | $2 (bitwise)
10010000001100000000000000000000	//OUT $3			Printa $3 (7)
01001100001100000100001000000000	//XOR $3 $1 $2		Faz $3 = $1 ^ $2 (bitwise)
10010000001100000000000000000000	//OUT $3			Printa $3 (7)
11011000001100000100000000000000	//NOT $3 $1			Faz $3 = ~$1 (bitwise)
10010000001100000000000000000000	//OUT $3			Printa $3 (FFFFFFFb)
11011100001100000100000000000001	//SHL $3 $1 1		Faz $3 = $1 << 1 (Rodado 1 posição)
10010000001100000000000000000000	//OUT $3			Printa $3 (8)
11100000001100000100000000000001	//SHR $3 $1 1		Faz $3 = $1 >> 1 (Rodado 1 posição)
10010000001100000000000000000000	//OUT $3			Printa $3 (2)
00111000001100000100001000000000	//STEQ $3 $1 $2		Faz $3 = 1, se $1 = $2. Senão $3 = 0
10010000001100000000000000000000	//OUT $3			Printa $3 (0)
00111100001100000100001000000000	//STGT $3 $1 $2		Faz $3 = 1, se $1 > $2. Senão $3 = 0
10010000001100000000000000000000	//OUT $3			Printa $3 (1)
01000000001100000100001000000000	//STLT $3 $1 $2		Faz $3 = 1, se $1 < $2. Senão $3 = 0
10010000001100000000000000000000	//OUT $3			Printa $3 (0)
01000100001100000100001000000000	//STNE $3 $1 $2		Faz $3 = 1, se $1 != $2. Senão $3 = 0
10010000001100000000000000000000	//OUT $3			Printa $3 (1)
10001100001100000000000000001111	//LI $3 15			Carrega 15(F) em $3
10001100010000000000000000111001	//LI $4 57			Carrega a linha do programa usada no próximo Branch
00001000010000000100001000000000	//BEQ $4 $1 $2		Branch caso $1 = $2, Se a condição for falso, Printa F e depois 0, se for verdadeira, Printa 0
10010000001100000000000000000000	//OUT $3
10010000000000000000000000000000	//OUT $0			Nesse caso Printa F depois 0
10001100010000000000000000111101	//LI $4 61			Carrega a linha do programa usada no próximo Branch
00001100010000000100001000000000	//BGE $4 $1 $2		Branch caso $1 >= $2, Se a condição for falso, Printa F e depois 0, se for verdadeira, Printa 0
10010000001100000000000000000000	//OUT $3
10010000000000000000000000000000	//OUT $0			Nesse caso Printa 0
10001100010000000000000001000001	//LI $4 65			Carrega a linha do programa usada no próximo Branch
00011100010000000100001000000000	//BNE $4 $1 $2		Branch caso $1 != $2, Se a condição for falso, Printa F e depois 0, se for verdadeira, Printa 0
10010000001100000000000000000000	//OUT $3
10010000000000000000000000000000	//OUT $0			Nesse caso Printa 0
10001100010000000000000001000101	//LI $4 69			Carrega a linha do programa usada no próximo Branch
00010100010000000100001000000000	//BLE $4 $1 $2		Branch caso $1 <= $2, Se a condição for falso, Printa F e depois 0, se for verdadeira, Printa 0
10010000001100000000000000000000	//OUT $3
10010000000000000000000000000000	//OUT $0			Nesse caso Printa F depois 0
10001100010000000000000001001001	//LI $4 73			Carrega a linha do programa usada no próximo Branch
00011000010000000100001000000000	//BLT $4 $1 $2		Branch caso $1 < $2, Se a condição for falso, Printa F e depois 0, se for verdadeira, Printa 0
10010000001100000000000000000000	//OUT $3
10010000000000000000000000000000	//OUT $0			Nesse caso Printa F depois 0
10001100010000000000000001010000	//LI $4 80			Carrega a linha do programa usada no próximo Jump
10000100010000000000000000000000	//JAL $4			Vai para a linha em $4 e armazena o retorno na pilha de retorno
10001100001100000000000000001110	//LI $3 14			Carrega 14(d) em $3
10010000001100000000000000000000	//OUT $3			Printa $3 (d)
00110000000000000000000000000000	//NOP				Não faz nada
00100100000000000000000000000000	//HALT				Para o processador
10010100000000000000000000000000	//RET				Retorna utilizando o topo da pilha de retorno
10001100001100000000000000001111	//LI $3 15			Carrega 15(F) em $3
10010000001100000000000000000000	//OUT $3			Caso RET falhe, Printa F